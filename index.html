<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tiny Bullet Hell â€” Fixed Reset, Enemy Shape, Hit Anim</title>
  <style>
    :root{--bg1:#071028;--bg2:#050814;--accent:#9ff}
    html,body{height:100%;}
    body{
      margin:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#fff;font-family:Inter,Segoe UI,Roboto,system-ui;overflow:hidden;
      user-select:none;
    }
    #gameWrap{width:100%;max-width:1100px;height:calc(100vh - 80px);display:flex;align-items:center;justify-content:center;position:relative;padding:12px}
    canvas{background:radial-gradient(ellipse at center,#071428 0%, #030512 60%);border-radius:10px;box-shadow:0 10px 40px rgba(0,0,0,.6);width:100%;height:100%;display:block}
    #hud{position:absolute;left:16px;top:12px;pointer-events:none}
    .info{position:absolute;right:16px;top:12px;text-align:right;font-size:13px;opacity:.95}
    .overlay{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,.65);padding:18px;border-radius:10px;text-align:center}
    button{background:#16a085;border:0;padding:8px 12px;border-radius:6px;color:white;cursor:pointer}
    #controls{width:100%;max-width:1100px;padding:10px 12px;display:flex;align-items:center;gap:12px;color:#ccc;font-size:14px}
    #difficultyLabel{min-width:100px;}
    input[type=range]{
      -webkit-appearance:none;
      width:200px;
      height:6px;
      border-radius:5px;
      background: #3498db;
      outline:none;
      opacity:0.9;
      transition:opacity .2s;
      cursor:pointer;
    }
    input[type=range]:hover {
      opacity:1;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance:none;
      appearance:none;
      width:18px;
      height:18px;
      border-radius:50%;
      background:#fff;
      cursor:pointer;
      box-shadow: 0 0 6px rgba(255,255,255,0.6);
      transition: background 0.3s ease;
    }
    input[type=range]::-moz-range-thumb {
      width:18px;
      height:18px;
      border-radius:50%;
      background:#fff;
      cursor:pointer;
      box-shadow: 0 0 6px rgba(255,255,255,0.6);
      transition: background 0.3s ease;
    }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="c"></canvas>
    <div id="deathScreen" class="overlay" style="display:none;">
      <h2>Game Over</h2>
      <p id="finalScore">Your score: 0</p>
      <button id="restartBtn">Restart</button>
    </div>
  </div>
  <div id="controls">
    <label for="difficultyRange" id="difficultyLabel">Difficulty: 1.0x</label>
    <input type="range" id="difficultyRange" min="0.5" max="3" step="0.01" value="1">
    <button id="muteBtn">ðŸ”Š Mute</button>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function fit(){
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    canvas.width = Math.floor(rect.width * devicePixelRatio);
    canvas.height = Math.floor(rect.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', fit);
  fit();

  const rand = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));

  let last = performance.now();
  let running = true; 
  let paused = false;
  let score = 0; 
  let lives = 3; 
  let levelTime = 0; 
  let spawnTimer = 0;
  let bossActive = false; 
  let boss = null; 
  let highScore = Number(localStorage.getItem('bh_hs')||0);
  let difficultyMult = 1;

  const keys = {};
  window.addEventListener('keydown', e=>{
    keys[e.key.toLowerCase()]=true;
    if(e.key==='p'||e.key==='P') paused = !paused;
    if(e.key==='f') toggleFull();
  });
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

  let pointer = {x:canvas.width/2,y:canvas.height/2,down:false};
  canvas.addEventListener('pointermove', e=>{
    const r = canvas.getBoundingClientRect();
    pointer.x = (e.clientX - r.left);
    pointer.y = (e.clientY - r.top);
  });
  canvas.addEventListener('pointerdown', e=>{ pointer.down = true; });
  window.addEventListener('pointerup', e=>{ pointer.down = false; });

  function toggleFull(){
    if(document.fullscreenElement) document.exitFullscreen();
    else document.documentElement.requestFullscreen();
  }

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let muted = false;

  function playBeep(freq=440, duration=0.1, volume=0.3){
    if(muted) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'square';
    osc.frequency.value = freq;
    gain.gain.value = volume;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
    osc.onended = () => gain.disconnect();
  }

  function sfxShoot(){ playBeep(880, 0.06, 0.14); }
  function sfxHit(){ playBeep(140, 0.15, 0.5); }
  function sfxEnemyDeath(){ playBeep(520, 0.2, 0.2); }
  function sfxGameOver(){ playBeep(100, 0.8, 0.6); }
  function sfxPowerup(){ playBeep(880, 0.15, 0.5); }

  const player = { 
    x: canvas.width/2, y: canvas.height/2, r: 10, speed: 260, 
    fireCooldown: 0, fireRate: 0.09, alive: true, hitTimer: 0
  };

  function Pool(create){ 
    this.items = []; 
    this.create = create; 
  }
  Pool.prototype.spawn = function(...a){ 
    let obj = this.items.find(i=>!i.active); 
    if(!obj){ 
      obj = this.create(...a); 
      this.items.push(obj);
    } else { 
      Object.assign(obj, this.create(...a)); 
    } 
    obj.active = true; 
    return obj; 
  }
  Pool.prototype.updateAll = function(dt,fn){ this.items.forEach(i=> i.active && fn(i,dt)); }

  const playerBullets = new Pool(()=>({x:0,y:0,vx:0,vy:0,r:3,speed:740,active:false,ttl:1.6}));
  const enemyBullets = new Pool(()=>({x:0,y:0,vx:0,vy:0,r:4,active:false,ttl:6,color:'rgba(255,120,120,0.95)'}));
  const enemies = new Pool(()=>({x:0,y:0,vx:0,vy:0,r:14,hp:1,type:'basic',phase:0,t:0,active:false}));
  const particles = new Pool(()=>({x:0,y:0,vx:0,vy:0,r:1,l:0,active:false,color:'rgba(255,255,255,0.9)'}));
  const powerups = new Pool(() => ({
    x: 0, y: 0, r: 8, active: false, type: '', vy: 40,
  }));

  const powerupTypes = [
    { type: 'life', color: 'crimson' },
    { type: 'fireRate', color: 'deepskyblue' },
    { type: 'shield', color: 'gold' },
  ];

  function spawnPlayerBullet(x,y,angle){
    const b = playerBullets.spawn();
    b.x=x;b.y=y;b.vx=Math.cos(angle)*b.speed;b.vy=Math.sin(angle)*b.speed;b.r=3;b.ttl=1.6;
    sfxShoot();
  }
  function spawnEnemyBullet(x,y,angle,speed,color){
    const b = enemyBullets.spawn();
    b.x=x;b.y=y;b.vx=Math.cos(angle)*speed;b.vy=Math.sin(angle)*speed;b.r=4;b.ttl=6;b.color=color||'rgba(255,120,120,0.95)';
  }
  function spawnParticle(x,y,vx,vy,life,color){
    const p = particles.spawn();
    p.x=x;p.y=y;p.vx=vx;p.vy=vy;p.l=life;p.r=1.5;p.active=true;p.color=color||'rgba(255,200,100,0.9)';
  }
  function spawnEnemy(x,y,type){
    const e = enemies.spawn();
    e.x=x;e.y=y;e.type=type||'basic'; e.vx=0; e.vy=0; 
    e.r = 14; // Circle radius fixed here
    e.hp = (type==='big'?20: type==='mini'?1: type==='turret'?6: type==='zig'?3:1); 
    e.phase=0; e.t=0; e.active=true;
  }

  function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function dropPowerup(x,y) {
    if (Math.random() < 0.2) {
      const pu = powerups.spawn();
      pu.x = x;
      pu.y = y;
      pu.type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)].type;
      pu.active = true;
      pu.vy = 40 + Math.random() * 20;
    }
  }

  function spawnWave(time){ 
    const df = difficultyMult;
    if(time < 6){ 
      if(Math.random() < 0.05 * df * 0.4) spawnEnemy(rand(40, canvas.width-40), -30, choose(['basic','mini'])); 
    }
    else if(time < 20){ 
      if(Math.random() < 0.06 * df * 0.5) spawnEnemy(rand(30, canvas.width-30), -30, choose(['basic','zig','mini'])); 
      if(Math.random() < 0.015*df) circularAttack(); 
    }
    else if(time < 45){ 
      if(Math.random() < 0.08 * df) spawnEnemy(rand(30, canvas.width-30), -40, choose(['basic','zig','shooter','mini'])); 
      if(Math.random() < 0.03*df) spiralEmitter(); 
    }
    else {
      if(Math.random() < 0.1 * df) spawnEnemy(rand(30, canvas.width-30), -40, choose(['basic','zig','shooter','kamikaze','turret','mini']));
      if(Math.random() < 0.04*df) spiralEmitter();
      if(Math.random() < 0.008*df && !bossActive) spawnBoss();
    }
  }

  function circularAttack(){ 
    const x = rand(80, canvas.width-80), y = -30; 
    spawnEnemy(x,y,'turret'); 
    setTimeout(()=>{ 
      for(let a=0;a<24;a++) spawnEnemyBullet(x,y, a*(Math.PI*2/24), 160 * difficultyMult, 'rgba(170,220,255,0.95)'); 
    }, 700); 
  }

  function spiralEmitter(){ 
    const cx = rand(80, canvas.width-80), cy = -20; 
    const steps = 80; 
    const base = Math.random()*Math.PI*2; 
    for(let i=0;i<steps;i++){ 
      ((i)=> setTimeout(()=> {
        const ang = base + i*0.28; 
        spawnEnemyBullet(cx+Math.sin(i*0.22)*36, cy + i*0.6, ang, 200 * difficultyMult, 'rgba(255,180,200,0.95)'); 
      }, i*30))(i); 
    } 
  }

  function spawnBoss(){ 
    bossActive = true; 
    boss = {
      x: canvas.width/2, y: -120, r:58, hp: 250 * difficultyMult, maxHp:250 * difficultyMult, phase:0, t:0
    }; 
  }

  let shieldTimer = 0;
  let fireRateBoostTimer = 0;

  function update(dt){ 
    if(paused || !running) return; 
    levelTime += dt; 
    spawnTimer += dt; 

    if(player.hitTimer > 0){
      player.hitTimer -= dt;
      if(player.hitTimer < 0) player.hitTimer = 0;
    }
    if(shieldTimer > 0) shieldTimer -= dt;
    if(fireRateBoostTimer > 0) fireRateBoostTimer -= dt;

    const spawnInterval = clamp(0.18 / Math.sqrt(difficultyMult), 0.05, 0.5);
    if(spawnTimer > spawnInterval){ 
      spawnWave(levelTime); 
      spawnTimer = 0; 
    }

    let targetX = clamp(pointer.x, Math.max(12, canvas.width * 0.02), canvas.width - Math.max(12, canvas.width * 0.02));
    let targetY = clamp(pointer.y, Math.max(12, canvas.height * 0.02), canvas.height - Math.max(12, canvas.height * 0.02));
    player.x = targetX;
    player.y = targetY;

    player.fireCooldown -= dt;
    const wantShoot = (keys[' ']|0) || pointer.down;
    const baseFireRate = 0.09;
    player.fireRate = fireRateBoostTimer > 0 ? baseFireRate * 0.6 : baseFireRate;

    if(wantShoot && player.fireCooldown <= 0){
      const spread = 0.14 + Math.log(1+difficultyMult)*0.02;
      for(let s=-1;s<=1;s++) spawnPlayerBullet(player.x, player.y - 8, -Math.PI/2 + s*spread);
      player.fireCooldown = player.fireRate * (1 - Math.min(0.5, Math.log(1+difficultyMult)*0.06));
    }

    playerBullets.updateAll(dt, b=>{
      b.x += b.vx*dt; 
      b.y += b.vy*dt; 
      b.ttl -= dt; 
      if(b.ttl<=0 || b.x < -20 || b.x > canvas.width+20 || b.y < -20 || b.y > canvas.height+20) b.active=false; 
    });
    enemyBullets.updateAll(dt, b=>{
      b.x += b.vx*dt; 
      b.y += b.vy*dt; 
      b.ttl -= dt; 
      if(b.ttl<=0 || b.x < -40 || b.x > canvas.width+40 || b.y < -40 || b.y > canvas.height+40) b.active=false; 
    });

    enemies.updateAll(dt, e=>{
      e.t += dt;
      if(e.type === 'basic'){
        if(e.y < 70) e.y += 60*dt;
        else { 
          e.y += 10*dt * (1 + difficultyMult*0.05); 
          e.x += Math.sin(e.t*1.6)*30*dt;
        }
      }
      else if(e.type==='mini'){
        e.y += 90 * dt * (1 + difficultyMult*0.15);
        e.x += Math.sin(e.t*12)*8*dt;
      }
      else if(e.type==='zig'){
        e.y += 110 * dt * (1 + difficultyMult*0.1);
        e.x += Math.sin(e.t*8) * 60 * dt;
      }
      else if(e.type==='shooter'){
        e.y += 25 * dt;
        if(e.t > 1 && e.t < 1.3 && Math.random() < 0.6)
          spawnEnemyBullet(e.x, e.y+10, Math.PI/2, 180 * difficultyMult, 'rgba(255,120,120,0.9)');
      }
      else if(e.type==='kamikaze'){
        e.y += 240 * dt * (1 + difficultyMult*0.2);
        e.x += Math.sin(e.t*15)*12*dt;
      }
      else if(e.type==='turret'){
        if(e.y < 60) e.y += 40*dt;
        else if(Math.floor(e.t*2) !== Math.floor((e.t-dt)*2)) {
          for(let a=0; a < 8; a++) spawnEnemyBullet(e.x, e.y, a*Math.PI/4, 160 * difficultyMult, 'rgba(170,220,255,0.95)');
        }
      }
      else if(e.type==='big'){
        if(e.y < 150) e.y += 20*dt;
        else e.y += 6*dt;
        if(e.t > 3 && Math.floor(e.t*3) !== Math.floor((e.t-dt)*3)) {
          for(let a=-1; a <= 1; a++) spawnEnemyBullet(e.x, e.y+15, Math.PI/2 + a*0.25, 190 * difficultyMult, 'rgba(255,150,150,0.8)');
        }
      }

      if(e.y - e.r > canvas.height + 20) e.active = false;
    });

    if(bossActive && boss){
      boss.t += dt;
      if(boss.y < 120) boss.y += 60 * dt;
      else {
        if(boss.phase === 0) {
          if(boss.t > 0.3) {
            for(let a=-1; a<=1; a++){
              spawnEnemyBullet(boss.x + a*20, boss.y+50, Math.PI/2 + a*0.15, 220 * difficultyMult, 'rgba(255,180,180,0.9)');
            }
            boss.t = 0;
            boss.phase = 1;
          }
        } else if(boss.phase === 1) {
          if(boss.t > 1.2) {
            for(let a=0; a<24; a++) spawnEnemyBullet(boss.x, boss.y, a*(Math.PI*2/24), 180 * difficultyMult, 'rgba(255,100,100,0.8)');
            boss.t = 0;
            boss.phase = 0;
          }
        }
      }
    }

    particles.updateAll(dt, p=>{
      p.x += p.vx*dt; p.y += p.vy*dt;
      p.l -= dt;
      if(p.l <= 0) p.active = false;
    });

    powerups.updateAll(dt, p => {
      p.y += p.vy * dt;
      if (p.y - p.r > canvas.height) p.active = false;

      if (p.active && Math.hypot(player.x - p.x, player.y - p.y) < player.r + p.r) {
        applyPowerup(p.type);
        p.active = false;
      }
    });

    if(player.alive && player.hitTimer <= 0 && shieldTimer <= 0){
      enemyBullets.items.forEach(b=>{
        if(b.active && Math.hypot(player.x - b.x, player.y - b.y) < player.r + b.r){
          b.active = false;
          playerHit();
        }
      });
      enemies.items.forEach(e=>{
        if(e.active && Math.hypot(player.x - e.x, player.y - e.y) < player.r + e.r){
          playerHit();
          e.hp -= 2;
          if(e.hp <= 0){
            dropPowerup(e.x, e.y);
            createEnemyDeath(e.x, e.y);
            e.active = false;
            score += 3;
          }
        }
      });
    }

    playerBullets.items.forEach(b=>{
      if(!b.active) return;
      enemies.items.forEach(e=>{
        if(e.active && Math.hypot(b.x - e.x, b.y - e.y) < b.r + e.r){
          e.hp--;
          b.active = false;
          sfxHit();
          if(e.hp <= 0){
            dropPowerup(e.x, e.y);
            createEnemyDeath(e.x, e.y);
            e.active = false;
            score += 1;
          }
        }
      });
      if(b.active && bossActive && boss){
        if(Math.hypot(b.x - boss.x, b.y - boss.y) < b.r + boss.r){
          boss.hp -= 1;
          b.active = false;
          sfxHit();
          updateBossHp();
          if(boss.hp <= 0){
            sfxEnemyDeath();
            bossActive = false;
            boss = null;
            score += 100;
            for(let i=0; i<40; i++){
              spawnParticle(
                rand(canvas.width/2 - 40, canvas.width/2 + 40),
                rand(canvas.height/2 - 40, canvas.height/2 + 40),
                rand(-90,90), rand(-90,90), 2, 'rgba(255,180,180,0.8)'
              );
            }
          }
        }
      }
    });

  }

  function applyPowerup(type){
    sfxPowerup();
    switch(type){
      case 'life':
        lives = Math.min(lives + 1, 5);
        break;
      case 'fireRate':
        fireRateBoostTimer = 6;
        break;
      case 'shield':
        shieldTimer = 6;
        break;
    }
  }

  function playerHit(){
    if(player.hitTimer > 0 || shieldTimer > 0) return;
    lives--;
    player.hitTimer = 1.5;
    sfxHit();
    if(lives <= 0) gameOver();
  }

  function createEnemyDeath(x,y){
    sfxEnemyDeath();
    for(let i=0; i<12; i++){
      spawnParticle(x, y, rand(-120,120), rand(-120,120), 0.7, 'rgba(255,200,150,0.9)');
    }
  }

  function gameOver(){
    sfxGameOver();
    running = false;
    player.alive = false;
    document.getElementById('deathScreen').style.display = 'block';
    document.getElementById('finalScore').textContent = 'Your score: ' + score;
    if(score > highScore){
      highScore = score;
      localStorage.setItem('bh_hs', highScore);
    }
  }

  document.getElementById('restartBtn').onclick = ()=>{
    document.getElementById('deathScreen').style.display = 'none';
    resetGame();
    if(!running){
      running = true;
      last = performance.now();
      requestAnimationFrame(loop);
    }
  };

  function resetGame(){
    score = 0; lives = 3; levelTime = 0; spawnTimer = 0; bossActive = false; boss = null;
    player.alive = true; player.hitTimer = 0; shieldTimer = 0; fireRateBoostTimer = 0;
    player.x = canvas.width/2; player.y = canvas.height/2;
    enemies.items.forEach(e=> e.active = false);
    playerBullets.items.forEach(b=> b.active = false);
    enemyBullets.items.forEach(b=> b.active = false);
    particles.items.forEach(p=> p.active = false);
    powerups.items.forEach(p=> p.active = false);
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();

    let grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 100, canvas.width/2, canvas.height/2, canvas.width/1.3);
    grad.addColorStop(0, '#0a1732');
    grad.addColorStop(1, '#010512');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    if(player.alive){
      ctx.shadowColor = shieldTimer > 0 ? 'gold' : 'white';
      ctx.shadowBlur = shieldTimer > 0 ? 12 : 8;

      // flashing effect when hit
      let alpha = 1;
      if(player.hitTimer > 0) alpha = 0.4 + 0.6 * Math.sin(player.hitTimer*20);

      ctx.fillStyle = shieldTimer > 0 ? `rgba(255,215,0,${alpha})` : `rgba(255,255,255,${alpha})`;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.r+4, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.beginPath();
      ctx.moveTo(player.x, player.y - player.r);
      ctx.lineTo(player.x - player.r*0.7, player.y + player.r);
      ctx.lineTo(player.x + player.r*0.7, player.y + player.r);
      ctx.closePath();
      ctx.fill();
    }

    ctx.fillStyle = '#9ff';
    playerBullets.items.forEach(b=>{
      if(!b.active) return;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    });

    enemies.items.forEach(e=>{
      if(!e.active) return;
      ctx.fillStyle = '#d05'; // basic enemy color
      if(e.type === 'mini') ctx.fillStyle = '#c87';
      else if(e.type === 'zig') ctx.fillStyle = '#9f5';
      else if(e.type === 'shooter') ctx.fillStyle = '#f56';
      else if(e.type === 'kamikaze') ctx.fillStyle = '#f33';
      else if(e.type === 'turret') ctx.fillStyle = '#4af';
      else if(e.type === 'big') ctx.fillStyle = '#d22';

      if(e.hp < (e.type==='big'?20:1)) ctx.globalAlpha = 0.6 + 0.4*Math.sin(e.t*60);

      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    });

    enemyBullets.items.forEach(b=>{
      if(!b.active) return;
      ctx.fillStyle = b.color || '#f99';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    });

    particles.items.forEach(p=>{
      if(!p.active) return;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    });

    powerups.items.forEach(p=>{
      if(!p.active) return;
      let color = 'white';
      if(p.type === 'life') color = 'crimson';
      else if(p.type === 'fireRate') color = 'deepskyblue';
      else if(p.type === 'shield') color = 'gold';
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'white';
      ctx.stroke();
    });

    if(bossActive && boss){
      ctx.fillStyle = 'crimson';
      ctx.shadowColor = 'crimson';
      ctx.shadowBlur = 14;
      ctx.beginPath();
      ctx.arc(boss.x, boss.y, boss.r, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Boss HP bar
      const barW = 280;
      const barH = 14;
      const x = canvas.width/2 - barW/2;
      const y = 20;
      ctx.fillStyle = 'rgba(200,0,0,0.3)';
      ctx.fillRect(x,y,barW,barH);
      ctx.fillStyle = 'crimson';
      ctx.fillRect(x,y, barW * clamp(boss.hp/boss.maxHp,0,1), barH);
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.strokeRect(x,y,barW,barH);
    }

    ctx.fillStyle = 'white';
    ctx.font = 'bold 18px monospace';
    ctx.fillText('Score: ' + score, 14, 28);
    ctx.fillText('Lives: ' + lives, 14, 56);

    if(shieldTimer > 0){
      const w = 120, h = 10, x = canvas.width - w - 20, y = 20;
      ctx.fillStyle = 'rgba(255,215,0,0.5)';
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = 'gold';
      ctx.fillRect(x, y, w * clamp(shieldTimer / 6, 0, 1), h);
      ctx.strokeStyle = 'white';
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'white';
      ctx.fillText('Shield', x + w/2 - 22, y + h - 2);
    }
    if(fireRateBoostTimer > 0){
      const w = 140, h = 10, x = canvas.width - w - 20, y = 40;
      ctx.fillStyle = 'rgba(30,144,255,0.4)';
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = 'deepskyblue';
      ctx.fillRect(x, y, w * clamp(fireRateBoostTimer / 6, 0, 1), h);
      ctx.strokeStyle = 'white';
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'white';
      ctx.fillText('Fire Rate', x + w/2 - 32, y + h - 2);
    }

    ctx.restore();
  }

  function updateBossHp(){
    // can extend for UI, currently handled in draw()
  }

  function loop(t){
    const dt = Math.min((t - last)/1000, 0.04);
    last = t;
    update(dt);
    draw();
    if(running) requestAnimationFrame(loop);
  }

  const diffSlider = document.getElementById('difficultyRange');
  const diffLabel = document.getElementById('difficultyLabel');
  diffSlider.addEventListener('input', e=>{
    difficultyMult = parseFloat(diffSlider.value);
    diffLabel.textContent = `Difficulty: ${difficultyMult.toFixed(2)}x`;
  });

  const muteBtn = document.getElementById('muteBtn');
  muteBtn.onclick = () => {
    muted = !muted;
    muteBtn.textContent = muted ? 'ðŸ”‡ Muted' : 'ðŸ”Š Mute';
  };

  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
